#  This file is part of Delaunay triangulation robust implementation.
#
#  Copyright (C) 2010, 2011  Vladimir Rutsky <altsysrq@gmail.com>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import itertools
import re
import subprocess
import tempfile
import datetime

Import('env')

class TestFailed(Exception):
    pass

def normalize_output(output):
    indices = map(int, output.split())
    assert len(indices) % 3 == 0
    
    triangles = zip(indices, indices[1:], indices[2:])[0::3]
    for idx, tr in enumerate(triangles[:]):
        triangles[idx] = min(tr, (tr[1], tr[2], tr[0]), (tr[2], tr[0], tr[1]))
        
    triangles.sort()
    
    result = "\n".join(map(lambda tr: " ".join(map(str, tr)), triangles))
    if result:
        result += "\n"
    return result

def runTests(env, target, source):
    import subprocess
    app = str(source[0].abspath)
    verificator = str(source[1].abspath)
    
    tests_dir = os.path.dirname(target[0].abspath)
    
    test_files = Glob(os.path.join(tests_dir, "*.in"), strings=True)
    failed_tests = []
    for test_file in test_files:
        test_name = os.path.basename(re.sub(r"\.in$", "", test_file))
        print " *** Running '{0}'".format(test_name)
        
        with open(test_file, 'r') as f:
            test_data = f.read()
    
        try:
            test_err_file = os.path.join(tests_dir, test_name + ".err")
            if os.path.exists(test_err_file):
                print "    Remove obsolete error log: '{0}'".format(os.path.relpath(test_err_file))
                os.remove(test_err_file)
        
            start_time = datetime.datetime.now()
            try:
                process = subprocess.Popen([app], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout, stderr = process.communicate(test_data)
                if process.returncode != 0 or len(stderr) > 0:
                    print "Test failed with error code {0}.\nstdout:\n{1}\nstderr:\n{2}\n".format(
                        process.returncode, stdout, stderr)
                    with open(test_err_file, 'w') as f:
                        f.write(stderr)
                    raise TestFailed()
            finally:
                time = datetime.datetime.now() - start_time
                print "    triangulation time:", time
            
            # Verify result.
            tmp_results_fd, tmp_results_file = tempfile.mkstemp(".tmp")
            os.close(tmp_results_fd)
            with open(tmp_results_file, 'w') as f:
                f.write(stdout)
            
            verification_err_file = os.path.join(tests_dir, test_name + ".ver_err")
            if os.path.exists(verification_err_file):
                print "    Remove obsolete verification error log: '{0}'".format(os.path.relpath(verification_err_file))
                os.remove(verification_err_file)
            
            start_time = datetime.datetime.now()
            try:
                process = subprocess.Popen([verificator, test_file, tmp_results_file], 
                    stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                verification_stdout, verification_stderr = process.communicate()
                if process.returncode != 0 or len(stderr) > 0:
                    print "Vertification returned error code {0}.\nstdout:\n{1}\nstderr:\n{2}\n".format(
                        process.returncode, verification_stdout, verification_stderr)
                    with open(verification_err_file, 'w') as f:
                        f.write(verification_stderr)
                    raise TestFailed()
            finally:
                time = datetime.datetime.now() - start_time
                print "    verification time:", time

                os.remove(tmp_results_file)
            
            test_result_file = os.path.join(tests_dir, test_name + ".out")
            new_test_result_file = os.path.join(tests_dir, test_name + ".new")
            output = normalize_output(stdout)
            if os.path.exists(test_result_file):
                if os.path.exists(new_test_result_file):
                    print "    Remove generated data due to fact that test output already exists: '{0}'".\
                        format(os.path.relpath(new_test_result_file))
                    os.remove(new_test_result_file)
            
                with open(test_result_file, 'r') as f:
                    test_correct_result = f.read()
                if not test_correct_result.startswith("dummy"):
                    if test_correct_result != output:
                        print "    Test failed due to different output."
                        with open(new_test_result_file, 'w') as f:
                            f.write(output)
                        print "    New result written to '{0}'".format(os.path.relpath(new_test_result_file))
                        raise TestFailed()
                    else:
                        pass
            else:
                pass
                #print "    Test has no precomputated results."
                #with open(new_test_result_file, 'w') as f:
                #    f.write(output)
                #print "    New result written to '{0}'".format(os.path.relpath(new_test_result_file))

        except TestFailed:
            failed_tests.append(test_name)
            print
        else:
            pass
      
    if len(failed_tests) == 0:
        #with open(str(target[0]), 'w') as f:
        #    f.write("PASSED\n")
        print "All tests succeded"
    else:
        print "Following tests failed:\n  " + ", ".join(failed_tests)

Command("test.passed", [env.my_main_program, env.verificator], runTests)
