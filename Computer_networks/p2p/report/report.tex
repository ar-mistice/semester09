% Report.
%
% Copyright (C) 2010, 2011  Vladimir Rutsky <altsysrq@gmail.com>
%
% This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 
% Unported License. See <http://creativecommons.org/licenses/by-sa/3.0/> 
% for details.

% TODO: Use styles according to GOST (it's hard).

\documentclass[a4paper,10pt]{article}

% Encoding support.
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}

\usepackage{amsmath, amsthm, amssymb}

% Indenting first paragraph.
\usepackage{indentfirst}

\usepackage{url}
\usepackage[unicode]{hyperref}

%\usepackage[final]{pdfpages}

\usepackage[pdftex]{graphicx}
\usepackage{subfig}

%TODO: use texments
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{texments}
%\usepackage{listings}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% Spaces after commas.
\frenchspacing
% Minimal carrying number of characters,
\righthyphenmin=2

% From K.V.Voroncov Latex in samples, 2005.
\textheight=24cm   % text height
\textwidth=16cm    % text width.
\oddsidemargin=0pt % left side indention
\topmargin=-1.5cm  % top side indention.
\parindent=24pt    % paragraph indent
\parskip=0pt       % distance between paragraphs.
\tolerance=2000
%\flushbottom       % page height aligning
%\hoffset=0cm
%\pagestyle{empty}  % without numeration

\newcommand{\myemail}[1]{%
\href{mailto:#1}{\nolinkurl{#1}}}

\newcommand{\myfunc}[1]{%
\textit{#1}}

\begin{document}

% Title page.
\input{./title.tex}

\tableofcontents
\pagebreak

% Content

\section{Постановка задачи}
Необходимо реализовать модель канального уровня сетевой модели OSI
и исследовать эффективность используемого в модели протокола передачи данных 
при наличии ошибок при передаче.

Для модели необходимо использовать протокол, 
использующий идею плавающего окна.

Передача ведётся по полнодуплексному каналу.
Данные должны передаваться с гарантией доставки.

\section{Выбранный метод решения}
\label{section:solution}
Для реализации был выбран протокол выборочного повтора (\textit{selective repeat}), 
описанный в~\cite{tanenbaum2003compnet}.

Протокол использует идею плавающего окна:
отправитель отправляет кадры в пределах некоторого <<окна>>~--- 
интервал ограниченной длины последовательно идущих кадров;
получатель ожидает кадров также в пределах своего рабочего окна.

При получении кадра получатель отправляет уведомление о доставке 
отправителю.
При получении уведомления о доставке отправитель сдвигает рабочее окно
таким образом, чтобы для первого кадра окна ещё не было получено
уведомления о доставке.
Аналогичным образом получатель поддерживает своё рабочее окно.

Для каждого отправленного кадра отправитель создаёт таймер, 
который подсчитывает сколько времени кадр находится в состоянии ожидания
уведомления о доставке.
В случае превышения времени ожидания для кадра устанавливается флаг ошибки доставки.

В протоколе с выборочным повтором обработка кадров с ошибкой доставки 
происходит следующим образом:
при обнаружении кадра с ошибкой доставки производится его повторная отправка.

\section{Детали реализации}
\subsection{Физический уровень передачи данных}
Модель физического уровеня передачи данных представлена 
классом \textit{узла} \myfunc{FullDuplexNode}
(см.~приложение~\ref{appendix:sources:duplex-link}).
Узлы конструируются связанными парами.
Каждый узел предоставляет два метода: \myfunc{write} и \myfunc{read}, 
позволяющие отправлять связанному узлу непрерывный поток байтов.

В реализации физического уровня предусмотрено внесение ошибок в передаваемые данные.
Возможно внесение ошибок трёх типов: подмена передаваемого байта, 
добавление лишнего байта, удаление передаваемого байта.

\subsection{Передачи данных фреймами}
Для удобства контроля передачи данных 
непрерывный поток байтов делится на группы байтов переменной длины~--- фреймы
(см.~приложение~\ref{appendix:sources:frame}).
Деление на фреймы делается по аналогии с делением в протоколе SLIP%
\footnote{\textit{Serial Line Internet Protocol}, описан в RFC 1055.}

\subsection{Передача данных датаграммами}
Поверх уровня передачи фреймами реализован протокол передачи с выборочным обменом,
описанный в разделе~\ref{section:solution} 
(см.~реализацию в приложении~\ref{appendix:sources:datagram}).

Передаваемые данные делятся на куски небольшого размера, 
упаковываются в датаграмму,
которая передаётся в виде фрейма через нижележащий уровень сети.

Используется датаграмма следующего формата (см.~таблицу~\ref{table:datagram}):
\begin{table}[h]
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      proto & src & dest & len & data & CRC32 \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Формат датаграммы.}
  \label{table:datagram}
\end{table}
\begin{itemize}
  \item \textbf{proto} (2 байта)~--- 
  идентификатор вышестоящего в сетевом стеке протокола;
  \item \textbf{src} (4 байта), \textbf{dest} (4 байта)~--- 
  идентификаторы отправителя и получателя датаграммы;
  \item \textbf{len} (4 байта)~--- длина поля данных;
  \item \textbf{data} ~--- данные;
  \item \textbf{CRC32} ~--- контрольная сумма пакета (CRC32%
\footnote{\textit{Сyclic redundancy check}~--- \textit{циклический избыточный код}, %
описан в~\cite{peterson1961crc}.%
}).
\end{itemize}


\section{Результат работы}
% Выборочный повтор более эффективен. 

\pagebreak

\appendix
\section{Исходный код}
\label{appendix:sources}

\usestyle{default}

\subsection{Полнодуплексная передача данных}
\label{appendix:sources:duplex-link}
\includecode[python -O linenos=1]{data/duplex_link.py}

\subsection{Передача данных фреймами}
\label{appendix:sources:frame}
\includecode[python -O linenos=1]{data/frame.py}

\subsection{Передача данных датаграммами}
\label{appendix:sources:datagram}
\includecode[python -O linenos=1]{data/datagram.py}

\pagebreak

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
